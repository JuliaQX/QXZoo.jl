var documenterSearchIndex = {"docs":
[{"location":"algo/rqc/#Random-Quantum-Circuits-(RQC)","page":"RQC","title":"Random Quantum Circuits (RQC)","text":"","category":"section"},{"location":"algo/rqc/","page":"RQC","title":"RQC","text":"The RQC module aims to generate RQC capable of demonstrating results as those of Villalonga et al (npj Quantum Inf 5, 86 (2019)) and Arute et al. (Nature volume 574, 505â€“510 (2019)).","category":"page"},{"location":"algo/rqc/#API","page":"RQC","title":"API","text":"","category":"section"},{"location":"algo/rqc/#rqc.jl","page":"RQC","title":"rqc.jl","text":"","category":"section"},{"location":"algo/rqc/","page":"RQC","title":"RQC","text":"QXZoo.RQC.RQC_DS(n::Int, m::Int)\nQXZoo.RQC.random_gate!(rqc::QXZoo.RQC.RQC_DS, i::Int, j::Int, rng::Random.MersenneTwister)\nQXZoo.RQC.patterns(rqc::QXZoo.RQC.RQC_DS)\nQXZoo.RQC.create_RQC(rows::Int, cols::Int, depth::Int, seed::Union{Int, Nothing}=nothing; use_iswap::Bool=false, final_Hadamard_layer::Bool=false)","category":"page"},{"location":"algo/rqc/#QXZoo.RQC.RQC_DS-Tuple{Int64, Int64}","page":"RQC","title":"QXZoo.RQC.RQC_DS","text":"RQC creation structure.\n\nHolds the circuit, and generator datatypes\n\n\n\n\n\n","category":"method"},{"location":"algo/rqc/#QXZoo.RQC.random_gate!-Tuple{QXZoo.RQC.RQC_DS, Int64, Int64, MersenneTwister}","page":"RQC","title":"QXZoo.RQC.random_gate!","text":"random_gate!(rqc::RQC, i::Int, j::Int)\n\nReturns the gate name for the next single qubit gate to be applied to the qubit at (i, j).\n\n\n\n\n\n","category":"method"},{"location":"algo/rqc/#QXZoo.RQC.patterns-Tuple{QXZoo.RQC.RQC_DS}","page":"RQC","title":"QXZoo.RQC.patterns","text":"patterns(rqc::RQC)\n\nGenerate a dictionary of patterns of qubit pairs to apply two qubit gates to. The patterns are numbers 1 to 8 like in Boxio2018 but in a different order. (Note, the order used in Boxio2018 is 3, 1, 6, 8, 5, 7, 2, 4)\n\n\n\n\n\n","category":"method"},{"location":"algo/rqc/#QXZoo.RQC.create_RQC","page":"RQC","title":"QXZoo.RQC.create_RQC","text":"create_RQC(rows::Int, cols::Int, depth::Int,\n                    seed::Union{Int, Nothing}=nothing;\n                    use_iswap::Bool=false,\n                    final_Hadamard_layer::Bool=false)\n\nGenerate a random quantum circuit with a (rows x cols) grid of qubits. The parameter 'depth' is the number of one and two qubit gate layers to be used in the circuit.\n\nThe single qubit gates used are chossen randomly from the set {T, sqrt(X), sqrt(Y)}. The seed for the random selection can be set with the seed parameter.\n\nCZ gates are used by default as the two qubit gates.  [TODO] Setting 'use_iswap' to true will use iSWAP gates inplace of CZ gates.\n\nSetting 'finalHadamardlayer' to true will include a layer of Hadamard gates at the end of the circuit.\n\n\n\n\n\n","category":"function"},{"location":"algo/rqc/#Example","page":"RQC","title":"Example","text":"","category":"section"},{"location":"algo/rqc/","page":"RQC","title":"RQC","text":"To use the Grover module, we provide example code below to search for a state in a 5-qubit quantum register marked by bit-pattern 11 (0b01011).","category":"page"},{"location":"algo/rqc/","page":"RQC","title":"RQC","text":"using QXZoo\n\n# Set 2D qubit grid size and circuit depth\nrows = 4\ncols = 5\ndepth = 7\n\n# Create RQC circuit using built-in generator\ncct = QXZoo.RQC.create_RQC(rows, cols, depth)\n\nprintln(cct)\n\nfor i in cct.circ_ops\n    println(i)\nend","category":"page"},{"location":"algo/grover/#Grover-Search","page":"Grover","title":"Grover Search","text":"","category":"section"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"The Grover.jl module implements a Grover's search use-case. Assisted by Oracle.jl and Diffusion.jl, the appropriate chosen test state is marked by applying an nCZ gate, and appropriately amplified through the required number of iterations rapprox pisqrt2^n+14.","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"To apply the Grover search algorithm, we require additional functionalities in the form an oracle to select the required state, and a diffusion operator to shift the state ampltiudes.","category":"page"},{"location":"algo/grover/#API","page":"Grover","title":"API","text":"","category":"section"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"QXZoo.Grover.bitstring_ncu!(cct::QXZoo.Circuit.Circ, bitstring::Integer, ctrl_indices::Vector, tgt_idx::Int, U::QXZoo.GateOps.GateSymbol, aux_indices::Vector=Int[])\nQXZoo.Grover.bitstring_phase_oracle!(cct::QXZoo.Circuit.Circ, bitstring::Integer, ctrl_indices::Vector, tgt_idx::Int, aux_indices::Vector=Int[])\nQXZoo.Grover.apply_diffusion!(cct::QXZoo.Circuit.Circ, ctrl_indices::Vector, tgt_index::Int, aux_indices::Vector=Int[])\nQXZoo.Grover.run_grover!(cct::QXZoo.Circuit.Circ, qubit_indices::Vector, state::Integer)\nQXZoo.Grover.mark_state!(cct::QXZoo.Circuit.Circ, state::Integer, qubit_indices::Vector)\nQXZoo.Grover.apply_grover_iteration!(cct::QXZoo.Circuit.Circ, qubit_indices::Vector)\nQXZoo.Grover.state_init!(cct::QXZoo.Circuit.Circ, qubit_indices::Vector)\nQXZoo.Grover.calc_iterations(num_states::Integer)","category":"page"},{"location":"algo/grover/#QXZoo.Grover.bitstring_ncu!","page":"Grover","title":"QXZoo.Grover.bitstring_ncu!","text":"bitstring_ncu(cct::Circuit.Circ, bitstring::Integer, ctrl_indices::Vector, tgt_idx::Int, U::GateOps.GateSymbol, aux_indices::Vector=Int[])\n\nTakes bitstring as the binary pattern and indices as the qubits to operate upon. Applies the appropriate PauliX gates to the control lines to call the NCU with the given matrix. Uses aux_indices to reduce Circuit depth by expanding width if |aux|+2 >= |ctrl|. If not specified, uses default quadratic gate expansion.\n\n\n\n\n\n","category":"function"},{"location":"algo/grover/#QXZoo.Grover.bitstring_phase_oracle!","page":"Grover","title":"QXZoo.Grover.bitstring_phase_oracle!","text":"bitstring_phase_oracle(cct::Circuit.Circ, bitstring::Integer, ctrl_indices::Vector, tgt_idx::Int, aux_indices::Vector=Int[])\n\nApplies PauliX gates to the appropriate lines in the Circuit, then applies a n-controlled PauliZ to mark the state. Uses aux qubits to reduce circuit depth if |aux|+2 >= |ctrl|. If not provided, uses quadratic gate expansion\n\n\n\n\n\n","category":"function"},{"location":"algo/grover/#QXZoo.Grover.apply_diffusion!","page":"Grover","title":"QXZoo.Grover.apply_diffusion!","text":"apply_diffusion(cct::Circuit.Circ, ctrl_indices::Vector, tgt_index::Int, aux_indices::Vector=Int[] )\n\nApplication of the Grover diffusion operator to marked register. Uses additionally provided auxiliary qubits to reduce depth.\n\n\n\n\n\n","category":"function"},{"location":"algo/grover/#QXZoo.Grover.run_grover!-Tuple{QXZoo.Circuit.Circ, Vector{T} where T, Integer}","page":"Grover","title":"QXZoo.Grover.run_grover!","text":"run_grover!(cct::Circuit.Circ, qubit_indices::Vector, state::Integer=1, qubit_aux_indices::Vector=Int[])\n\nGenerates a Grover search Circuit sample, marking the state defined by state and performing iterations to amplify the desired result upon measurement.\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QXZoo.Grover.mark_state!-Tuple{QXZoo.Circuit.Circ, Integer, Vector{T} where T}","page":"Grover","title":"QXZoo.Grover.mark_state!","text":"mark_state!(cct::Circuit.Circ, state::Integer, qubit_indices::Vector, qubit_aux_indices::Vector)\n\nApplies the state marking procedure of the Grover iteration.\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QXZoo.Grover.apply_grover_iteration!-Tuple{QXZoo.Circuit.Circ, Vector{T} where T}","page":"Grover","title":"QXZoo.Grover.apply_grover_iteration!","text":"apply_grover_iteration!(cct::Circuit.Circ, qubit_indices::Vector, qubit_aux_indices::Vector)\n\nApplies a single Grover iteration. To be used following mark_state!\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QXZoo.Grover.state_init!-Tuple{QXZoo.Circuit.Circ, Vector{T} where T}","page":"Grover","title":"QXZoo.Grover.state_init!","text":"state_init!(cct::Circuit.Circ, qubit_indices::Vector)\n\nInitialises the state to the required target; defaults to H^otimes nvert psi rangle . Override for custom initialisation.\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QXZoo.Grover.calc_iterations-Tuple{Integer}","page":"Grover","title":"QXZoo.Grover.calc_iterations","text":"calc_iterations(num_qubits::Integer)\n\nCalculate the required number of iterations to maximise the state's amplitude.\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#Example","page":"Grover","title":"Example","text":"","category":"section"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"To use the Grover module, we provide example code below to search for a state in a 5-qubit quantum register marked by bit-pattern 11 (0b01011).","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"using QXZoo\n\n# Set 10-qubit limit on circuit\nnum_qubits = 10\n\n# Set bit-pattern to 11 (0b01011)\nbit_pattern = 11\n\n# Create empty circuit with qiven qubit count\ncct = QXZoo.Circuit.Circ(num_qubits)\n\n# Run Grover algorithm for given oracle bit-pattern\nQXZoo.Grover.run_grover!(cct, collect(1:num_qubits), bit_pattern)\n\nprintln(cct)","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"Similarly, for an optimised variant of the same operations using more qubits:","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"using QXZoo\n\n# Set 10-qubit limit on Grover circuit (aux assisted)\nnum_qubits = 17\n\nqubits_range = 1:Int((num_qubits+1)/2) + 1 \naux_range = Int((num_qubits+1)/2 + 2):num_qubits\n\n# Set bit-pattern to 11 (0b01011)\nbit_pattern = 11\n\n# Create empty circuit with qiven qubit count\ncct = QXZoo.Circuit.Circ(num_qubits)\n\n# Run Grover algorithm for given oracle bit-pattern\nQXZoo.Grover.run_grover!(cct, collect(qubits_range), bit_pattern, collect(aux_range))\n\nprintln(cct)","category":"page"},{"location":"gates_circuits/circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"To compose a quantum algorithm, we need a structured manner for representing the gate calls, as defined in GateOps.md. ","category":"page"},{"location":"gates_circuits/circuits/#Circuit.jl","page":"Circuits","title":"Circuit.jl","text":"","category":"section"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"The Circuit.jl module allows us to structure the gate-calls into a quantum circuit representation. Circuits are appendable, pushable, and are represented under the hood as a doubly linked-list (see circuits/utils/DLList.jl), to allow ease of further optimisation and manipulation, if required.","category":"page"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"The Circuit module also maintains a cached mapping from GateSymbols to numerical matrices, wherein new gates created are stored for later use by other circuits. This memoization improves the performance of constructing circuits involving calculating sub-matrices (see the algorithms modules for examples).","category":"page"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"QXZoo.Circuit.Circ\nQXZoo.Circuit.Circ()\nQXZoo.Circuit.Circ(num_qubits::Int)\nQXZoo.Circuit.Circ(num_qubits::Int, gate_set::Set{<:QXZoo.GateOps.AGateSymbol})\n\nQXZoo.Circuit.num_qubits(circuit::QXZoo.Circuit.Circ)\n\nQXZoo.Circuit.add_gatecall!(circ::QXZoo.Circuit.Circ, gc::QXZoo.GateOps.GateCall1)\nQXZoo.Circuit.add_gatecall!(circ::QXZoo.Circuit.Circ, gc::QXZoo.GateOps.GateCall2)\n\nQXZoo.Circuit.export_circuit(cct::QXZoo.Circuit.Circ, file_name::String=\"circuit\")\nQXZoo.Circuit.load_circuit(file_name::String=\"circuit\")","category":"page"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.Circ","page":"Circuits","title":"QXZoo.Circuit.Circ","text":"Circ\n\nStructure for ordered quantum circuit gate operations.  Maintains mutable Doubly Linked List (DLList) of gate-calls and a set of the gates used.\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.Circ-Tuple{}","page":"Circuits","title":"QXZoo.Circuit.Circ","text":"Circ()\n\nDefault constructor for empty circuit. Registers Pauli and Hadamard gates during initialisation.\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.Circ-Tuple{Int64}","page":"Circuits","title":"QXZoo.Circuit.Circ","text":"Circ(num_qubits::Int)\n\nCirc constructor for given number of qubits circuit. Registers Pauli and Hadamard gates during initialisation.\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.Circ-Tuple{Int64, Set{var\"#s1\"} where var\"#s1\"<:AGateSymbol}","page":"Circuits","title":"QXZoo.Circuit.Circ","text":"Circ(num_qubits::Int, gate_set::Set{<:GateOps.AGateSymbol})\n\nCirc constructor for given number of qubits circuit. Registers Pauli and Hadamard gates during initialisation, and the included gate_set.\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.num_qubits-Tuple{QXZoo.Circuit.Circ}","page":"Circuits","title":"QXZoo.Circuit.num_qubits","text":"num_qubits(circuit::Circ)::Int\n\nReturn the number of qubits for the given circuit.\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.add_gatecall!-Tuple{QXZoo.Circuit.Circ, GateCall1}","page":"Circuits","title":"QXZoo.Circuit.add_gatecall!","text":"add_gatecall!(circ::Circ, gc::GateOps.AGateCall)\n\nAdds the given gate call gc to the circuit at the end position.\n\nExample 1\n\njulia> Circuit.add_gatecall!(circ, DefaultGates.x(4)) #Apply Paulix to qubit index 4\n\nThis functionality is also added by overloading << and used as:\n\nExample 2\n\njulia> circ << GateOps.x(4) #Apply Paulix to qubit index 4\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.add_gatecall!-Tuple{QXZoo.Circuit.Circ, GateCall2}","page":"Circuits","title":"QXZoo.Circuit.add_gatecall!","text":"add_gatecall!(circ::Circ, gc::GateOps.AGateCall)\n\nAdds the given gate call gc to the circuit at the end position.\n\nExample 1\n\njulia> Circuit.add_gatecall!(circ, DefaultGates.x(4)) #Apply Paulix to qubit index 4\n\nThis functionality is also added by overloading << and used as:\n\nExample 2\n\njulia> circ << GateOps.x(4) #Apply Paulix to qubit index 4\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.export_circuit","page":"Circuits","title":"QXZoo.Circuit.export_circuit","text":"export_circuit(cct::Circ, file_name::String=\"circuit\")\n\nExports the circuit to disk as a JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/circuits/#QXZoo.Circuit.load_circuit","page":"Circuits","title":"QXZoo.Circuit.load_circuit","text":"load_circuit(file_name::String=\"circuit\")\n\nLoads the circuit at file_name.jld2 from disk.\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"using QXZoo\n\nqubits = 10\n\n# Create empty circuit with qiven qubit count\ncct = QXZoo.Circuit.Circ(qubits)\n\nfor i in 1:9\n    QXZoo.Circuit.add_gatecall!(cct, QXZoo.DefaultGates.x(i) )\nend\n\n# Additional way to add a gate\ncct << QXZoo.DefaultGates.z(10)\n\nprintln(cct)\n\n# Save circuit to disk\nQXZoo.Circuit.export_circuit(cct)\n\n#Reload circuit from disk\nQXZoo.Circuit.load_circuit(cct)","category":"page"},{"location":"gates_circuits/GateOps/#Gate-Operations","page":"Gate Operations","title":"Gate Operations","text":"","category":"section"},{"location":"gates_circuits/GateOps/#Gate-type-system-hierarchy","page":"Gate Operations","title":"Gate type-system hierarchy","text":"","category":"section"},{"location":"gates_circuits/GateOps/","page":"Gate Operations","title":"Gate Operations","text":"Abstraction of types for representing gates.","category":"page"},{"location":"gates_circuits/GateOps/","page":"Gate Operations","title":"Gate Operations","text":"QXZoo.GateOps.AGate\nQXZoo.GateOps.AGateSymbol\nQXZoo.GateOps.AGateCall","category":"page"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.AGate","page":"Gate Operations","title":"QXZoo.GateOps.AGate","text":"Abstract Gate type\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.AGateSymbol","page":"Gate Operations","title":"QXZoo.GateOps.AGateSymbol","text":"Abstract Gate Label, for unique gates\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.AGateCall","page":"Gate Operations","title":"QXZoo.GateOps.AGateCall","text":"Abstract Gate Call, for tracking Gate labels applied to specific qubits\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#GateSymbol-and-GateCall","page":"Gate Operations","title":"GateSymbol and GateCall","text":"","category":"section"},{"location":"gates_circuits/GateOps/","page":"Gate Operations","title":"Gate Operations","text":"Specific gate instance in a circuit, applied to a given (set of) qubit(s).","category":"page"},{"location":"gates_circuits/GateOps/","page":"Gate Operations","title":"Gate Operations","text":"QXZoo.GateOps.GateSymbol\nQXZoo.GateOps.GateSymbolP\nQXZoo.GateOps.GateCall1\nQXZoo.GateOps.GateCall2\nQXZoo.GateOps.GateCallN\nQXZoo.GateOps.Gate","category":"page"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.GateSymbol","page":"Gate Operations","title":"QXZoo.GateOps.GateSymbol","text":"Gate label. Tracks the gate symbol (:x,:y,:z, etc)\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.GateSymbolP","page":"Gate Operations","title":"QXZoo.GateOps.GateSymbolP","text":"Gate label with params. Tracks the gate symbol (:x,:y,:z, etc)\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.GateCall1","page":"Gate Operations","title":"QXZoo.GateOps.GateCall1","text":"Single qubit Gate call. Has a GateSymbol, target qubit index\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.GateCall2","page":"Gate Operations","title":"QXZoo.GateOps.GateCall2","text":"Two qubit Gate call.  Has a GateSymbol, control and target qubit indices, and base gate.\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.GateCallN","page":"Gate Operations","title":"QXZoo.GateOps.GateCallN","text":"n-qubit Gate call.  Has a GateSymbol, control vector indices, target qubit index, and base gate.\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QXZoo.GateOps.Gate","page":"Gate Operations","title":"QXZoo.GateOps.Gate","text":"Wrap of Matrix to fit type system hierarchy\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateMap/#GateMap","page":"GateMap","title":"GateMap","text":"","category":"section"},{"location":"gates_circuits/GateMap/","page":"GateMap","title":"GateMap","text":"Given many algorithms will have repeated use of specific custom or parametric gates, it can be useful to store these for later use. In addition, to allow use of the GateSymbol type to represent numeric matrices, we require a location to provide this mapping. This module operates as this cache, and allows sotrage for gates generated during the circuit creation.","category":"page"},{"location":"gates_circuits/GateMap/","page":"GateMap","title":"GateMap","text":"The GateMap.gates dictionary defines a mapping between GateSymbols & Functions to a given generator Function. To aid with ease of translation and extensibility, additional platforms may define the base gate mappings here to generator the required out structures for a given target platform.","category":"page"},{"location":"gates_circuits/GateMap/","page":"GateMap","title":"GateMap","text":"For our use as a framework for creating tensor network simulations, we map the required GateSymbols and Functions to produce StaticArrays types for numerical representation.","category":"page"},{"location":"gates_circuits/GateMap/#Utility-and-types","page":"GateMap","title":"Utility and types","text":"","category":"section"},{"location":"gates_circuits/GateMap/","page":"GateMap","title":"GateMap","text":"QXZoo.GateMap.gates\nQXZoo.GateMap.init_cache()\nQXZoo.GateMap.cache_gate!(key::Union{QXZoo.GateOps.GateSymbol, QXZoo.GateOps.GateSymbolP, Function}, mat_func::Function)\nQXZoo.GateMap.clear_cache()\n\nQXZoo.GateMap.create_gate_1q(gate_label::String, gen_func::Function)\nQXZoo.GateMap.create_gate_1q(gate_label::String, mat::Array{<:Number,2})\nQXZoo.GateMap.create_gate_2q(gate_label::String, gen_func::Function)\nQXZoo.GateMap.create_gate_2q(gate_label::String, mat::Array{<:Number,2})","category":"page"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.gates","page":"GateMap","title":"QXZoo.GateMap.gates","text":"Module gate cache\n\nSince many different circuits may use the same gates, keeping a module-global  cache makes sense to avoid recreating them. Each subcircuit can have a subset of  the global cache's gates.\n\n\n\n\n\n","category":"constant"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.init_cache-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.init_cache","text":"init_cache()\n\nInitialise the cache for default gates used in circuit generation. Modules generating gates not stored here should cache them for use by other circuits.\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.cache_gate!-Tuple{Union{Function, GateSymbol, GateSymbolP}, Function}","page":"GateMap","title":"QXZoo.GateMap.cache_gate!","text":"cache_gate!(label::GateOps.AGateSymbol, mat::Matrix{<:Number})\n\nAdds a mapping between label=>mat for fast retrieval of gates in circuit generation.\n\nExamples\n\njulia> QXZoo.GateMap.cache_gate!(QXZoo.GateOps.GateSymbol(:mygate), ()->[ 1 0; 0 1])\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.clear_cache-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.clear_cache","text":"clear_cache()\n\nEmpty the stored gates from the cache.\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.create_gate_1q-Tuple{String, Function}","page":"GateMap","title":"QXZoo.GateMap.create_gate_1q","text":"create_gate_1q(gate_label::String, gen_func::Function)\n\nCreates a new user-defined gate, caches the generating function, and returns the GateOps.GateSymbol key for use in a circuit.\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.create_gate_1q-Tuple{String, Matrix{var\"#s1\"} where var\"#s1\"<:Number}","page":"GateMap","title":"QXZoo.GateMap.create_gate_1q","text":"create_gate_1q(gate_label::String, mat::Array{Complex{Float64},2})\n\nCreates a new user-defined gate, caches the generating matrix, and returns the GateOps.GateSymbol key for use in a circuit. Matrix is converted to 2x2 StaticArrays SMatrix internally.\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.create_gate_2q-Tuple{String, Function}","page":"GateMap","title":"QXZoo.GateMap.create_gate_2q","text":"create_gate_2q(gate_label::String, gen_func::Function)\n\nCreates a new user-defined gate, caches the generating function, and returns the GateOps.GateSymbol key for use in a circuit.\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.create_gate_2q-Tuple{String, Matrix{var\"#s1\"} where var\"#s1\"<:Number}","page":"GateMap","title":"QXZoo.GateMap.create_gate_2q","text":"create_gate_2q(gate_label::String, mat::Array{Complex{Float64},2})\n\nCreates a new user-defined gate, caches the generating matrix, and returns the GateOps.GateSymbol key for use in a circuit. Matrix is converted to 2x2 StaticArrays SMatrix internally.\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#Gate-generator-functions","page":"GateMap","title":"Gate generator functions","text":"","category":"section"},{"location":"gates_circuits/GateMap/","page":"GateMap","title":"GateMap","text":"QXZoo.GateMap.p00()\nQXZoo.GateMap.p01()\nQXZoo.GateMap.p10()\nQXZoo.GateMap.p11()\n\nQXZoo.GateMap.x()\nQXZoo.GateMap.y()\nQXZoo.GateMap.z()\nQXZoo.GateMap.h()\nQXZoo.GateMap.s()\nQXZoo.GateMap.t()\nQXZoo.GateMap.I()\n\nQXZoo.GateMap.r_x(Î¸::Number)\nQXZoo.GateMap.r_y(Î¸::Number)\nQXZoo.GateMap.r_z(Î¸::Number)\nQXZoo.GateMap.r_phase(Î¸::Number)\n\nQXZoo.GateMap.c_x()\nQXZoo.GateMap.c_y()\nQXZoo.GateMap.c_z()\n\nQXZoo.GateMap.c_r_x(Î¸::Number)\nQXZoo.GateMap.c_r_y(Î¸::Number)\nQXZoo.GateMap.c_r_z(Î¸::Number)\nQXZoo.GateMap.c_r_phase(Î¸::Number)","category":"page"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.p00-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.p00","text":"p00()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the |0><0| projector gate.\n\nExamples\n\njulia> QXZoo.GateMap.p00()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.p01-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.p01","text":"p01()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the |0><1| projector gate.\n\nExamples\n\njulia> QXZoo.GateMap.p01()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.0+0.0im  1.0+0.0im\n 0.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.p10-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.p10","text":"p10()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the |1><0| projector gate.\n\nExamples\n\njulia> QXZoo.GateMap.p10()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.p11-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.p11","text":"p11()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the |1><1| projector gate.\n\nExamples\n\njulia> QXZoo.GateMap.p11()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.x-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.x","text":"x()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the Pauli-X gate.\n\nExamples\n\njulia> QXZoo.GateMap.x()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.y-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.y","text":"y()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the Pauli-Y gate.\n\nExamples\n\njulia> QXZoo.GateMap.y()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.0+0.0im  -0.0-1.0im\n 0.0+1.0im   0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.z-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.z","text":"z()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the Pauli-Z gate.\n\nExamples\n\njulia> QXZoo.GateMap.z()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.h-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.h","text":"h()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the Hadamard gate.\n\nExamples\n\njulia> QXZoo.GateMap.h()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.707107+0.0im   0.707107+0.0im\n 0.707107+0.0im  -0.707107+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.s-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.s","text":"s()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the S gate (sqrt(Z)).\n\nExamples\n\njulia> QXZoo.GateMap.s()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.t-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.t","text":"t()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the T gate (sqrt(S)).\n\nExamples\n\njulia> QXZoo.GateMap.t()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.I-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.I","text":"I()::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the 2x2 identity gate.\n\nExamples\n\njulia> QXZoo.GateMap.I()\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.r_x-Tuple{Number}","page":"GateMap","title":"QXZoo.GateMap.r_x","text":"r_x(Î¸::Number)::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the parametric r_x gate: exp(-0.5imÎ¸x())\n\nExamples\n\njulia> QXZoo.GateMap.r_x(pi/3)\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.866025+0.0im       0.0-0.5im\n      0.0-0.5im  0.866025+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.r_y-Tuple{Number}","page":"GateMap","title":"QXZoo.GateMap.r_y","text":"r_y(Î¸::Number)::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the parametric r_y gate: exp(-0.5imÎ¸y())\n\nExamples\n\njulia> QXZoo.GateMap.r_y(pi/6)\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.965926+0.0im  -0.258819+0.0im\n 0.258819+0.0im   0.965926+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.r_z-Tuple{Number}","page":"GateMap","title":"QXZoo.GateMap.r_z","text":"r_z(Î¸::Number)::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the parametric r_z gate: exp(-0.5imÎ¸z())\n\nExamples\n\njulia> QXZoo.GateMap.r_z(pi/2)\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 0.707107-0.707107im       0.0+0.0im\n      0.0+0.0im       0.707107+0.707107im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.r_phase-Tuple{Number}","page":"GateMap","title":"QXZoo.GateMap.r_phase","text":"r_phase(Î¸::Number)::SArray{Tuple{2,2},Complex{Float64},2,4}\n\nFunction which generates the parametric phase shifting gate [1 0; 0 exp(1im*Î¸)]. Note, this is not the Phase gate.\n\nExamples\n\njulia> QXZoo.GateMap.r_phase(pi/4)\n2Ã—2 StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4} with indices SOneTo(2)Ã—SOneTo(2):\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.c_x-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.c_x","text":"c_x()::SArray{Tuple{4,4},Complex{Float64},2,16}\n\nFunction which generates the controlled Pauli-X gate as a block diagonal 4x4 matrix.\n\nExamples\n\njulia> QXZoo.GateMap.c_x()\n4Ã—4 StaticArrays.SArray{Tuple{4,4},Complex{Float64},2,16} with indices SOneTo(4)Ã—SOneTo(4):\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.c_y-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.c_y","text":"c_y()::SArray{Tuple{4,4},Complex{Float64},2,16}\n\nFunction which generates the controlled Pauli-X gate as a block diagonal 4x4 matrix.\n\nExamples\n\njulia> QXZoo.GateMap.c_y()\n4Ã—4 StaticArrays.SArray{Tuple{4,4},Complex{Float64},2,16} with indices SOneTo(4)Ã—SOneTo(4):\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.c_z-Tuple{}","page":"GateMap","title":"QXZoo.GateMap.c_z","text":"c_z()::SArray{Tuple{4,4},Complex{Float64},2,16}\n\nFunction which generates the controlled Pauli-X gate as a block diagonal 4x4 matrix.\n\nExamples\n\njulia> QXZoo.GateMap.c_z()\n4Ã—4 StaticArrays.SArray{Tuple{4,4},Complex{Float64},2,16} with indices SOneTo(4)Ã—SOneTo(4):\n 1.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -1.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.c_r_x-Tuple{Number}","page":"GateMap","title":"QXZoo.GateMap.c_r_x","text":"c_r_x(Î¸::Number)::SArray{Tuple{4,4},Complex{Float64},2,16}\n\nFunction which generates the controlled parametric r_x gate as a block diagonal 4x4 matrix.\n\nExamples\n\njulia> QXZoo.GateMap.c_r_x(pi/3)\n4Ã—4 StaticArrays.SArray{Tuple{4,4},Complex{Float64},2,16} with indices SOneTo(4)Ã—SOneTo(4):\n 1.0+0.0im  0.0+0.0im       0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.866025+0.0im       0.0-0.5im\n 0.0+0.0im  0.0+0.0im       0.0-0.5im  0.866025+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.c_r_y-Tuple{Number}","page":"GateMap","title":"QXZoo.GateMap.c_r_y","text":"c_r_y(Î¸::Number)::SArray{Tuple{4,4},Complex{Float64},2,16}\n\nFunction which generates the controlled parametric r_y gate as a block diagonal 4x4 matrix.\n\nExamples\n\njulia> QXZoo.GateMap.c_r_y(pi/4)\n4Ã—4 StaticArrays.SArray{Tuple{4,4},Complex{Float64},2,16} with indices SOneTo(4)Ã—SOneTo(4):\n 1.0+0.0im  0.0+0.0im       0.0+0.0im        0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im        0.0+0.0im\n 0.0+0.0im  0.0+0.0im   0.92388+0.0im  -0.382683+0.0im\n 0.0+0.0im  0.0+0.0im  0.382683+0.0im    0.92388+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.c_r_z-Tuple{Number}","page":"GateMap","title":"QXZoo.GateMap.c_r_z","text":"c_r_z(Î¸::Number)::SArray{Tuple{4,4},Complex{Float64},2,16}\n\nFunction which generates the controlled parametric r_y gate as a block diagonal 4x4 matrix.\n\nExamples\n\njulia> QXZoo.GateMap.c_r_z(pi/6)\n4Ã—4 StaticArrays.SArray{Tuple{4,4},Complex{Float64},2,16} with indices SOneTo(4)Ã—SOneTo(4):\n 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.965926-0.258819im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im       0.0+0.0im       0.965926+0.258819im\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/GateMap/#QXZoo.GateMap.c_r_phase-Tuple{Number}","page":"GateMap","title":"QXZoo.GateMap.c_r_phase","text":"c_r_phase(Î¸::Number)::SArray{Tuple{4,4},Complex{Float64},2,16}\n\nFunction which generates the controlled parametric phase shifting gate [1 0; 0 exp(1im*Î¸)] as a block diagonal 4x4 matrix.\n\nNote, this is not the controlled Phase gate. \n\nExamples\n\njulia> QXZoo.GateMap.c_r_phase(pi/9)\n4Ã—4 StaticArrays.SArray{Tuple{4,4},Complex{Float64},2,16} with indices SOneTo(4)Ã—SOneTo(4):\n 1.0+0.0im  0.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.939693+0.34202im\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#NCU-module","page":"NCU","title":"NCU module","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"The NCU module enables the implementation of an n-qubit controlled unitary gate. In this instances, we have chosen to work primarily with nCX and nCZ gates, though others may also be used.","category":"page"},{"location":"algo/ncu/#Implementation","page":"NCU","title":"Implementation","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"The general principle follows the work of Barenco et al., Phys. Rev. A 52, 3457, (1995). All higher-order controlled quantum gates can be decomposed into 1 and 2 qubit gate calls, with varying degrees of optimisation. We implement the default quadratic gate decomposition strategy, alongside the 3CU optimised, and auxiliary register optimised variants.","category":"page"},{"location":"algo/ncu/#API","page":"NCU","title":"API","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"QXZoo.NCU.apply_ncu!(circuit::QXZoo.Circuit.Circ, q_ctrl::Vector, q_aux::Vector, q_tgt, U::QXZoo.GateOps.GateSymbol)\nQXZoo.NCU.get_intermed_gate(U::QXZoo.GateOps.GateSymbol)","category":"page"},{"location":"algo/ncu/#QXZoo.NCU.apply_ncu!-Tuple{QXZoo.Circuit.Circ, Vector{T} where T, Vector{T} where T, Any, GateSymbol}","page":"NCU","title":"QXZoo.NCU.apply_ncu!","text":"apply_ncu!(cct::Circuit.Circ, q_ctrl::Vector, q_aux::Vector, q_tgt, U::GateOps.GateSymbol)\n\nApply an n-qubit controlled gate operation on the given target qubit. Ensure the 2-qubit gate corresponding with symbol c_U is registered with GateMap.gates before use. Appends the GateCall operations to circuit\n\nArguments\n\ncct::Circuit.Circ\nctrls::Vector: \naux::Vector: \ntgt::Int:\nU::GateOps.GateSymbol: symbol for 2-qubit gate to extend (cx, cz, etc)\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#QXZoo.NCU.get_intermed_gate-Tuple{GateSymbol}","page":"NCU","title":"QXZoo.NCU.get_intermed_gate","text":"get_intermed_gate(U::GateOps.GateSymbol)\n\nGenerate sqrt U and adjoint sqrt U, given a previously cached gate U.\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#Example","page":"NCU","title":"Example","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"To use the NCU module, we provide example code below to apply an n-controlled Pauli Z gate using either the unoptimised (quadratic) or optimised (linear) decomposition routines.","category":"page"},{"location":"algo/ncu/#Default-NCU-with-3CU-optimisation","page":"NCU","title":"Default NCU with 3CU optimisation","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"using QXZoo\n\n# Set 10-qubit limit on circuit\nnum_qubits = 10\n\n# Create Pauli-Z gate-label for application\ngate_z = QXZoo.DefaultGates.GateSymbols.c_z\n\n# Create empty circuit with qiven qubit count\ncct = QXZoo.Circuit.Circ(num_qubits)\n\nctrl = collect(range(1, length=num_qubits  ) ) \naux = []\ntgt = num_qubits\n\nfor i in ctrl\n    QXZoo.Circuit.add_gatecall!(cct, QXZoo.DefaultGates.x(i) )\nend\n\nQXZoo.NCU.apply_ncu!(cct, ctrl, aux, tgt, gate_z)\n\n# Number of generation gate-call operations\nprintln(cct)","category":"page"},{"location":"algo/ncu/#Auxiliary-optimised-NCU","page":"NCU","title":"Auxiliary optimised NCU","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"# Auxiliary-assisted NCU\n\nusing QXZoo\n\n# 19 qubit aux-optimised matches 10 qubit unoptimised.\nnum_qubits = 19\n\ncct = QXZoo.Circuit.Circ(num_qubits)\n\nctrl = collect(1:10)\ntgt = 11\naux =  collect(11:19)\n\nfor i in ctrl\n    cct << QXZoo.DefaultGates.x(i)\nend\n\nQXZoo.NCU.apply_ncu!(cct, ctrl, aux, tgt, DefaultGates.GateSymbols.c_z)\n\nprintln(cct)","category":"page"},{"location":"algo/qft/#Quantum-Fourier-Transform-(QFT)","page":"QFT","title":"Quantum Fourier Transform (QFT)","text":"","category":"section"},{"location":"algo/qft/","page":"QFT","title":"QFT","text":"The QFT module enables the creation of circuit for n-qubit quantum Fourier transforms, and their inverses.","category":"page"},{"location":"algo/qft/#API","page":"QFT","title":"API","text":"","category":"section"},{"location":"algo/qft/#rqc.jl","page":"QFT","title":"rqc.jl","text":"","category":"section"},{"location":"algo/qft/","page":"QFT","title":"QFT","text":"QXZoo.QFT.apply_qft!(cct::QXZoo.Circuit.Circ, qubit_indices::Vector)\nQXZoo.QFT.apply_qft!(cct::QXZoo.Circuit.Circ)\nQXZoo.QFT.apply_iqft!(cct::QXZoo.Circuit.Circ, qubit_indices::Vector)\nQXZoo.QFT.apply_iqft!(cct::QXZoo.Circuit.Circ)\nQXZoo.QFT.swap_idx(qubit_indices::Vector)","category":"page"},{"location":"algo/qft/#QXZoo.QFT.apply_qft!-Tuple{QXZoo.Circuit.Circ, Vector{T} where T}","page":"QFT","title":"QXZoo.QFT.apply_qft!","text":"apply_qft!(cct::Circuit.Circ, qubit_indices::Vector)\n\nApply the quantum Fourier transform over the given qubit index range.\n\n\n\n\n\n","category":"method"},{"location":"algo/qft/#QXZoo.QFT.apply_qft!-Tuple{QXZoo.Circuit.Circ}","page":"QFT","title":"QXZoo.QFT.apply_qft!","text":"apply_qft!(cct::Circuit.Circ)\n\nApply the quantum Fourier transform over the entire qubit register\n\n\n\n\n\n","category":"method"},{"location":"algo/qft/#QXZoo.QFT.apply_iqft!-Tuple{QXZoo.Circuit.Circ, Vector{T} where T}","page":"QFT","title":"QXZoo.QFT.apply_iqft!","text":"apply_qft!(cct::Circuit.Circ, qubit_indices::Vector)\n\nApply the inverse quantum Fourier transform over the given qubit index range.\n\n\n\n\n\n","category":"method"},{"location":"algo/qft/#QXZoo.QFT.apply_iqft!-Tuple{QXZoo.Circuit.Circ}","page":"QFT","title":"QXZoo.QFT.apply_iqft!","text":"apply_iqft!(cct::Circuit.Circ)\n\nApply the inverse quantum Fourier transform over the entire qubit register\n\n\n\n\n\n","category":"method"},{"location":"algo/qft/#QXZoo.QFT.swap_idx-Tuple{Vector{T} where T}","page":"QFT","title":"QXZoo.QFT.swap_idx","text":"swap_idx(qubit_indices::Vector)\n\nReturn the indices of the qubits required to apply the swap operations as part of the transform.\n\n\n\n\n\n","category":"method"},{"location":"algo/qft/#Example","page":"QFT","title":"Example","text":"","category":"section"},{"location":"algo/qft/","page":"QFT","title":"QFT","text":"The following demonstrates the application of the QFT to a subset of qubits in the register, and the IQFT to the entire register.","category":"page"},{"location":"algo/qft/","page":"QFT","title":"QFT","text":"using QXZoo\n\ncct = QXZoo.Circuit.Circ(8)\n\nQXZoo.QFT.apply_qft!(cct, collect(1:4))\nQXZoo.QFT.apply_iqft!(cct)\n\nprintln(cct)\n\nfor i in cct.circ_ops\n    println(i)\nend","category":"page"},{"location":"gates_circuits/DefaultGates/#DefaultGates","page":"DefaultGates","title":"DefaultGates","text":"","category":"section"},{"location":"gates_circuits/DefaultGates/#DefaultGates.GateSymbols","page":"DefaultGates","title":"DefaultGates.GateSymbols","text":"","category":"section"},{"location":"gates_circuits/DefaultGates/","page":"DefaultGates","title":"DefaultGates","text":"Here we store symbols for the gates available in DefaultGates, and generator functions for parameteric variants of these gates. This allows us to track the mappings as to be used by the gate type hierarchy and architecture.","category":"page"},{"location":"gates_circuits/DefaultGates/#Commonly-used-gates","page":"DefaultGates","title":"Commonly used gates","text":"","category":"section"},{"location":"gates_circuits/DefaultGates/","page":"DefaultGates","title":"DefaultGates","text":"The functions in this module allow use to create a QXZoo.GateOps.AGateCall struct for a given qubit target and symbol type.","category":"page"},{"location":"gates_circuits/DefaultGates/#Single-Qubit-Gates:-default","page":"DefaultGates","title":"Single Qubit Gates: default","text":"","category":"section"},{"location":"gates_circuits/DefaultGates/","page":"DefaultGates","title":"DefaultGates","text":"QXZoo.DefaultGates.x(q_target::Int)\nQXZoo.DefaultGates.y(q_target::Int)\nQXZoo.DefaultGates.z(q_target::Int)\nQXZoo.DefaultGates.h(q_target::Int)\nQXZoo.DefaultGates.s(q_target::Int)\nQXZoo.DefaultGates.t(q_target::Int)","category":"page"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.x-Tuple{Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.x","text":"x(q_target::Int)\n\nGenerate a single qubit Pauli-x GateCall (GateCall1) applied to the target qubit \n\nExamples\n\njulia> QXZoo.DefaultGates.x(0)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbol(:x, 0, false), 0)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.y-Tuple{Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.y","text":"y(q_target::Int)\n\nGenerate a single qubit Pauli-y GateCall (GateCall1) applied to the  target qubit\n\nExamples\n\njulia> QXZoo.DefaultGates.y(0)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbol(:y, 0, false), 0)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.z-Tuple{Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.z","text":"z(q_target::Int)\n\nGenerate a single qubit Pauli-z GateCall (GateCall1) applied to the  target qubit\n\nExamples\n\njulia> QXZoo.DefaultGates.z(0)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbol(:z, 0, false), 0)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.h-Tuple{Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.h","text":"h(q_target::Int)\n\nGenerate a single qubit Hadamard GateCall (GateCall1) applied to the  target qubit\n\nExamples\n\njulia> QXZoo.DefaultGates.h(0)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbol(:h, 0, false), 0)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.s-Tuple{Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.s","text":"s(q_target::Int)\n\nGenerate a single qubit S GateCall (GateCall1) applied to the  target qubit (s == sqrt(z))\n\nExamples\n\njulia> QXZoo.DefaultGates.s(0)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbol(:z, 1, false), 0)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.t-Tuple{Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.t","text":"s(q_target::Int)\n\nGenerate a single qubit T GateCall (GateCall1) applied to the  target qubit (t == sqrt(s))\n\nExamples\n\njulia> QXZoo.DefaultGates.t(0)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbol(:z, 2, false), 0)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#Single-Qubit-Gates:-rotation-and-arbitrary","page":"DefaultGates","title":"Single Qubit Gates: rotation and arbitrary","text":"","category":"section"},{"location":"gates_circuits/DefaultGates/","page":"DefaultGates","title":"DefaultGates","text":"QXZoo.DefaultGates.u(label::QXZoo.GateOps.GateSymbol, q_target::Int )\nQXZoo.DefaultGates.r_x(q_target::Int, theta::Number )\nQXZoo.DefaultGates.r_y(q_target::Int, theta::Number )\nQXZoo.DefaultGates.r_z(q_target::Int, theta::Number )\nQXZoo.DefaultGates.r_phase(q_target::Int, theta::Number )","category":"page"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.u-Tuple{GateSymbol, Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.u","text":"u(label::GateSymbol, q_target::Int)\n\nGenerate a single qubit arbitrary unitary GateCall (GateCall1) applied to the  target qubit\n\nExamples\n\njulia> QXZoo.DefaultGates.u(QXZoo.GateOps.GateSymbol(:mygate), 1)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbol(:mygate, 0, false), 1)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.r_x-Tuple{Int64, Number}","page":"DefaultGates","title":"QXZoo.DefaultGates.r_x","text":"r_x(q_target::Int, theta::Number)\n\nGenerate a single qubit R_x(Î¸) GateCall (GateCall1) applied to the target qubit \n\nExamples\n\njulia> QXZoo.DefaultGates.r_x(3,pi/2)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbolP(:r_x, 0, false, 1.5707963267948966), 3)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.r_y-Tuple{Int64, Number}","page":"DefaultGates","title":"QXZoo.DefaultGates.r_y","text":"r_y(q_target::Int, theta::Number)\n\nGenerate a single qubit R_y(Î¸) GateCall (GateCall1) applied to the target qubit.\n\nExamples\n\njulia> QXZoo.DefaultGates.r_y(3,pi/2)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbolP(:r_y, 0, false, 1.5707963267948966), 3)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.r_z-Tuple{Int64, Number}","page":"DefaultGates","title":"QXZoo.DefaultGates.r_z","text":"r_z(q_target::Int, theta::Number)\n\nGenerate a single qubit R_z(Î¸) GateCall (GateCall1) applied to the target qubit\n\nExamples\n\njulia> QXZoo.DefaultGates.r_z(3,pi/2)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbolP(:r_z, 0, false, 1.5707963267948966), 3)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.r_phase-Tuple{Int64, Number}","page":"DefaultGates","title":"QXZoo.DefaultGates.r_phase","text":"r_phase(q_target::Int, theta::Number)\n\nGenerate a single qubit phase shift GateCall ( diag(1, exp(1im*theta)) , GateCall1) applied to the target qubit\n\nExamples\n\njulia> QXZoo.DefaultGates.r_phase(3,pi/2)\nQXZoo.GateOps.GateCall1(QXZoo.GateOps.GateSymbolP(:r_phase, 0, false, 1.5707963267948966), 3)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#Two-Qubit-Gates:-default","page":"DefaultGates","title":"Two Qubit Gates: default","text":"","category":"section"},{"location":"gates_circuits/DefaultGates/","page":"DefaultGates","title":"DefaultGates","text":"QXZoo.DefaultGates.c_x(q_target::Int, q_ctrl::Int )\nQXZoo.DefaultGates.c_y(q_target::Int, q_ctrl::Int )\nQXZoo.DefaultGates.c_z(q_target::Int, q_ctrl::Int )","category":"page"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.c_x-Tuple{Int64, Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.c_x","text":"c_x(q_target::Int, q_ctrl::Int)\n\nGenerate a controlled Pauli-x (two qubit) GateCall (GateCall2), controlled on the index q_ctrl applied to the target q_target.\n\nExamples\n\njulia> QXZoo.DefaultGates.c_x(0, 1)\nQXZoo.GateOps.GateCall2(QXZoo.GateOps.GateSymbol(:c_x, 0, false), 0, 1, QXZoo.GateOps.GateSymbol(:x, 0, false))\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.c_y-Tuple{Int64, Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.c_y","text":"c_y(q_target::Int, q_ctrl::Int)\n\nGenerate a controlled Pauli-y (two qubit) GateCall (GateCall2), controlled on the index q_ctrl applied to the target q_target.\n\nExamples\n\njulia> QXZoo.DefaultGates.c_y(0, 1)\nQXZoo.GateOps.GateCall2(QXZoo.GateOps.GateSymbol(:c_y, 0, false), 0, 1, QXZoo.GateOps.GateSymbol(:y, 0, false))\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.c_z-Tuple{Int64, Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.c_z","text":"c_z(q_target::Int, q_ctrl::Int)\n\nGenerate a controlled Pauli-x (two qubit) GateCall (GateCall2), controlled on the index q_ctrl applied to the target q_target.\n\nExamples\n\njulia> QXZoo.DefaultGates.c_z(0, 1)\nQXZoo.GateOps.GateCall2(QXZoo.GateOps.GateSymbol(:c_z, 0, false), 0, 1, QXZoo.GateOps.GateSymbol(:z, 0, false))\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#Two-Qubit-Gates:-rotation-and-arbitrary","page":"DefaultGates","title":"Two Qubit Gates: rotation and arbitrary","text":"","category":"section"},{"location":"gates_circuits/DefaultGates/","page":"DefaultGates","title":"DefaultGates","text":"QXZoo.DefaultGates.c_u(label::QXZoo.GateOps.GateSymbol, q_target::Int, q_ctrl::Int )\nQXZoo.DefaultGates.c_r_x(q_target::Int, q_ctrl::Int, theta::Number )\nQXZoo.DefaultGates.c_r_y(q_target::Int, q_ctrl::Int, theta::Number )\nQXZoo.DefaultGates.c_r_z(q_target::Int, q_ctrl::Int, theta::Number )\nQXZoo.DefaultGates.c_r_phase(q_target::Int, q_ctrl::Int, theta::Number )","category":"page"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.c_u-Tuple{GateSymbol, Int64, Int64}","page":"DefaultGates","title":"QXZoo.DefaultGates.c_u","text":"c_u(label::GateSymbol, q_target::Int, q_ctrl::Int)\n\nGenerate a controlled unitary (two qubit) GateCall (GateCall2), controlled on the index q_ctrl applied to the target q_target.\n\nExamples\n\njulia> QXZoo.DefaultGates.c_u(QXZoo.GateOps.GateSymbol(:myCU), 0, 1)\nQXZoo.GateOps.GateCall2(QXZoo.GateOps.GateSymbol(:myCU, 0, false), 0, 1, nothing)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.c_r_x-Tuple{Int64, Int64, Number}","page":"DefaultGates","title":"QXZoo.DefaultGates.c_r_x","text":"c_r_x(q_target::Int, q_ctrl::Int, theta::Number)\n\nGenerate a controlled rotation about x (exp(-iÎ¸x/2)) GateCall (GateCall2), controlled on the index q_ctrl applied to the target q_target.\n\nExamples\n\njulia> QXZoo.DefaultGates.c_r_x( 0, 1, pi/2)\nQXZoo.GateOps.GateCall2(QXZoo.GateOps.GateSymbolP(:c_r_x, 0, false, 1.5707963267948966), 0, 1, nothing)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.c_r_y-Tuple{Int64, Int64, Number}","page":"DefaultGates","title":"QXZoo.DefaultGates.c_r_y","text":"c_r_y(q_target::Int, q_ctrl::Int, theta::Number)\n\nGenerate a controlled rotation about y (exp(iÎ¸y/2)) GateCall (GateCall2), controlled on the index q_ctrl applied to the target q_target.\n\nExamples\n\njulia> QXZoo.DefaultGates.c_r_y( 0, 1, pi/3)\nQXZoo.GateOps.GateCall2(QXZoo.GateOps.GateSymbolP(:c_r_y, 0, false, 1.0471975511965976), 0, 1, nothing)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.c_r_z-Tuple{Int64, Int64, Number}","page":"DefaultGates","title":"QXZoo.DefaultGates.c_r_z","text":"c_r_z(q_target::Int, q_ctrl::Int, theta::Number)\n\nGenerate a controlled rotation about z (exp(iÎ¸z/2)) GateCall (GateCall2), controlled on the index q_ctrl applied to the target q_target\n\nExamples\n\njulia> QXZoo.DefaultGates.c_r_z( 0, 1, pi/4)\nQXZoo.GateOps.GateCall2(QXZoo.GateOps.GateSymbolP(:c_r_z, 0, false, 0.7853981633974483), 0, 1, nothing)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/DefaultGates/#QXZoo.DefaultGates.c_r_phase-Tuple{Int64, Int64, Number}","page":"DefaultGates","title":"QXZoo.DefaultGates.c_r_phase","text":"c_r_phase(q_target::Int, q_ctrl::Int, theta::Real)\n\nGenerate a controlled phase rotation about (controlled [1 0; 0 exp(iÎ¸)] GateCall (GateCall2), controlled on the index q_ctrl applied to the target q_target.\n\nExamples\n\njulia> QXZoo.DefaultGates.c_r_phase( 0, 1, pi/7 )\nQXZoo.GateOps.GateCall2(QXZoo.GateOps.GateSymbolP(:c_r_phase, 0, false, 0.4487989505128276), 0, 1, nothing)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/CompositeGates/#Composite-Gates","page":"Composite Gates","title":"Composite Gates","text":"","category":"section"},{"location":"gates_circuits/CompositeGates/","page":"Composite Gates","title":"Composite Gates","text":"This module is used for gates that can be composed of more fundamental gate operations. For simplicity, we refer to these as Composite Gates, and represent them as their numerical matrix values.","category":"page"},{"location":"gates_circuits/CompositeGates/#CompositeGates.GateSymbols","page":"Composite Gates","title":"CompositeGates.GateSymbols","text":"","category":"section"},{"location":"gates_circuits/CompositeGates/","page":"Composite Gates","title":"Composite Gates","text":"As in DefaultGates, we store symbols for the gates available in CompositeGates, and generator functions for parameteric variants of these gates. This allows us to track the mappings as to be used by the gate type hierarchy and architecture.","category":"page"},{"location":"gates_circuits/CompositeGates/#Two-Qubit-Gates:-static","page":"Composite Gates","title":"Two Qubit Gates: static","text":"","category":"section"},{"location":"gates_circuits/CompositeGates/","page":"Composite Gates","title":"Composite Gates","text":"QXZoo.CompositeGates.swap(q_target1::Int, q_target2::Int)\nQXZoo.CompositeGates.iswap(q_target1::Int, q_target2::Int)","category":"page"},{"location":"gates_circuits/CompositeGates/#QXZoo.CompositeGates.swap-Tuple{Int64, Int64}","page":"Composite Gates","title":"QXZoo.CompositeGates.swap","text":"swap(q_target1::Int, q_target2::Int)\n\nGenerate a SWAP gate equivalent circuit, composed of fundamental gate operations (CX)\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/CompositeGates/#QXZoo.CompositeGates.iswap-Tuple{Int64, Int64}","page":"Composite Gates","title":"QXZoo.CompositeGates.iswap","text":"iswap(q_target1::Int, q_target2::Int)\n\nGenerate a iSWAP gate equivalent circuit, generatable using  exp(1im*(pi/4)*(kron(GateMap.x(),GateMap.x()) + kron(GateMap.y(),GateMap.y())))\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/CompositeGates/#Two-Qubit-Gates:-rotation","page":"Composite Gates","title":"Two Qubit Gates: rotation","text":"","category":"section"},{"location":"gates_circuits/CompositeGates/","page":"Composite Gates","title":"Composite Gates","text":"QXZoo.CompositeGates.xx(q_target1::Int, q_target2::Int, Î¸::Number)\nQXZoo.CompositeGates.yy(q_target1::Int, q_target2::Int, Î¸::Number)\nQXZoo.CompositeGates.zz(q_target1::Int, q_target2::Int, Î¸::Number)","category":"page"},{"location":"gates_circuits/CompositeGates/#QXZoo.CompositeGates.xx-Tuple{Int64, Int64, Number}","page":"Composite Gates","title":"QXZoo.CompositeGates.xx","text":"xx(q_target1::Int, q_target2::Int, theta::Real)\n\nGenerate a XX parametric gate-equivalent circuit, composed of fundamental gate operations (H, CX, Rz)\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/CompositeGates/#QXZoo.CompositeGates.yy-Tuple{Int64, Int64, Number}","page":"Composite Gates","title":"QXZoo.CompositeGates.yy","text":"yy(q_target1::Int, q_target2::Int, theta::Real)\n\nGenerate a YY parametric gate, which can be constructed from fundamental 1 & 2 qubit operations\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/CompositeGates/#QXZoo.CompositeGates.zz-Tuple{Int64, Int64, Number}","page":"Composite Gates","title":"QXZoo.CompositeGates.zz","text":"zz(q_target1::Int, q_target2::Int, theta::Real)\n\nGenerate a ZZ parametric gate, which can be constructed from fundamental 1 & 2 qubit operations\n\nExamples\n\n\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To best use the QXZoo.jl package, we provide some examples below of expected use-cases.","category":"page"},{"location":"examples/#.-Creating-an-empty-5-qubit-circuit-and-add-default-gates","page":"Examples","title":"1. Creating an empty 5-qubit circuit and add default gates","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QXZoo\n\n# Create a 5-qubit Circ struct from the Circuit module to organise gates\ncirc = Circuit.Circ(5)\n\n# Insert Pauli gates into the circuit for given qubit indices\ncirc << DefaultGates.x(1) #explicit location\ncirc << y(2) #using exported symbols\ncirc << h(3)\n\n# Default gate addition function call\nCircuit.add_gatecall!(circ, DefaultGates.z(4))\n\ncirc << DefaultGates.c_x(1,5)\ncirc << c_z(2,5)\n\nprintln(circ)\nprintln(circ.gate_set)","category":"page"},{"location":"examples/#.-Combining-existing-circuits","page":"Examples","title":"2. Combining existing circuits","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example creates two separate circuits, and combines their operations. Not that the second circuit will close ownership of all its operations following a combine step.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QXZoo\n\n# Create two 8-qubit Circ struct from the Circuit module to organise gates\ncirc1 = Circuit.Circ(8)\ncirc2 = Circuit.Circ(8)\n\ncirc1 << x(1)\ncirc1 << c_y(1,2)\ncirc1 << h(3)\nprintln(circ1)\nprintln(circ1.gate_set)\n\ncirc2 << c_x(1,2)\ncirc2 << c_z(3,1)\ncirc2 << c_x(1,3)\nprintln(circ2)\nprintln(circ2.gate_set)\n\n# The following operation performs the combination\n# append!(circ1,circ2) withe short-hand given below\ncirc1 << circ2\n\nprintln(circ1)\nprintln(circ1.gate_set)\nprintln(circ2)\nprintln(circ2.gate_set)","category":"page"},{"location":"examples/#.-Using-parametric-gates","page":"Examples","title":"3. Using parametric gates","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Many quantum circuits require parametric (e.g. rotation) gates. Here we demonstrate their usage.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QXZoo\n\n# Create two 8-qubit Circ struct from the Circuit module to organise gates\ncirc = Circuit.Circ(5)\n\ncirc << r_x(1, pi/4)\ncirc << r_y(2, pi/3)\ncirc << r_y(3, 1)\ncirc << c_r_y(1, 3, pi/9)\ncirc << c_r_x(1, 3, pi/2)\ncirc << c_r_phase(1, 3, -pi/2)\nprintln(circ)\nprintln(circ.gate_set)","category":"page"},{"location":"examples/#.-Creating-custom-gates","page":"Examples","title":"4. Creating custom gates","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Custom gates can also be used. First, we must register the gate with the GateMap cache utility. The gate may then be used with the u functions and return GateSymbol struct.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QXZoo\n\n# Single qubit gates\n\nfunction custom_gate_1q()\n    return [1 0; 0 -1im]\nend\n\nmy_gate = create_gate_1q(\"my_gate\", custom_gate_1q)\n\n# Two qubit gates\n\nfunction custom_gate_2q()\n    return kron([1 0; 0 1], [1 0; 0 1])\nend\n\nmy_gate_2 = create_gate_2q(\"my_gate_2\", custom_gate_2q)\n\n# Create two 8-qubit Circ struct from the Circuit module to organise gates\ncirc = Circuit.Circ(5)\n\ncirc << u(my_gate, 1)\n\ncirc << c_u(my_gate_2, 1, 2)\n\nprintln(circ)\nprintln(circ.gate_set)","category":"page"},{"location":"#QXZoo.jl-Documentation","page":"Home","title":"QXZoo.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QXZoo.jl is a generator suite for quantum algorithms. Using a high-level approach to quantum circuit design, we create quantum circuits taking note of all intermediate gate-calls between qubits, performing operation caching and optimisation where possible. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, we support a limited set of quantum algorithms (see the MAnual/Algorithms dropdown for details). Details of the circuit generator modules and structs are given in the Gates and Circuits dropdowns.","category":"page"}]
}
